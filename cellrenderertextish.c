/* cellrenderertextish.c generated by valac 0.56.18-dirty, the Vala compiler
 * generated from cellrenderertextish.vala, do not modify */

/* compile with  valac -c cellrenderertextish.vala --pkg gtk+-3.0 -C -H cellrenderertextish.h */

#include "cellrenderertextish.h"
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <glib/gi18n-lib.h>
#include <cairo-gobject.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif

enum  {
	CELL_RENDERER_TEXTISH_0_PROPERTY,
	CELL_RENDERER_TEXTISH_NUM_PROPERTIES
};
static GParamSpec* cell_renderer_textish_properties[CELL_RENDERER_TEXTISH_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_CELL_EDITABLE_ACCEL (cell_editable_accel_get_type ())
#define CELL_EDITABLE_ACCEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CELL_EDITABLE_ACCEL, CellEditableAccel))
#define CELL_EDITABLE_ACCEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CELL_EDITABLE_ACCEL, CellEditableAccelClass))
#define IS_CELL_EDITABLE_ACCEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CELL_EDITABLE_ACCEL))
#define IS_CELL_EDITABLE_ACCEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CELL_EDITABLE_ACCEL))
#define CELL_EDITABLE_ACCEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CELL_EDITABLE_ACCEL, CellEditableAccelClass))

typedef struct _CellEditableAccel CellEditableAccel;
typedef struct _CellEditableAccelClass CellEditableAccelClass;

#define TYPE_CELL_EDITABLE_COMBO (cell_editable_combo_get_type ())
#define CELL_EDITABLE_COMBO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CELL_EDITABLE_COMBO, CellEditableCombo))
#define CELL_EDITABLE_COMBO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CELL_EDITABLE_COMBO, CellEditableComboClass))
#define IS_CELL_EDITABLE_COMBO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CELL_EDITABLE_COMBO))
#define IS_CELL_EDITABLE_COMBO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CELL_EDITABLE_COMBO))
#define CELL_EDITABLE_COMBO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CELL_EDITABLE_COMBO, CellEditableComboClass))

typedef struct _CellEditableCombo CellEditableCombo;
typedef struct _CellEditableComboClass CellEditableComboClass;

#define TYPE_CELL_EDITABLE_DUMMY (cell_editable_dummy_get_type ())
#define CELL_EDITABLE_DUMMY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CELL_EDITABLE_DUMMY, CellEditableDummy))
#define CELL_EDITABLE_DUMMY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CELL_EDITABLE_DUMMY, CellEditableDummyClass))
#define IS_CELL_EDITABLE_DUMMY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CELL_EDITABLE_DUMMY))
#define IS_CELL_EDITABLE_DUMMY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CELL_EDITABLE_DUMMY))
#define CELL_EDITABLE_DUMMY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CELL_EDITABLE_DUMMY, CellEditableDummyClass))

typedef struct _CellEditableDummy CellEditableDummy;
typedef struct _CellEditableDummyClass CellEditableDummyClass;
enum  {
	CELL_RENDERER_TEXTISH_KEY_EDITED_SIGNAL,
	CELL_RENDERER_TEXTISH_COMBO_EDITED_SIGNAL,
	CELL_RENDERER_TEXTISH_NUM_SIGNALS
};
static guint cell_renderer_textish_signals[CELL_RENDERER_TEXTISH_NUM_SIGNALS] = {0};
typedef struct _CellEditableDummyPrivate CellEditableDummyPrivate;
enum  {
	CELL_EDITABLE_DUMMY_0_PROPERTY,
	CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY,
	CELL_EDITABLE_DUMMY_NUM_PROPERTIES
};
static GParamSpec* cell_editable_dummy_properties[CELL_EDITABLE_DUMMY_NUM_PROPERTIES];
typedef struct _CellEditableAccelPrivate CellEditableAccelPrivate;
enum  {
	CELL_EDITABLE_ACCEL_0_PROPERTY,
	CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY,
	CELL_EDITABLE_ACCEL_NUM_PROPERTIES
};
static GParamSpec* cell_editable_accel_properties[CELL_EDITABLE_ACCEL_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _Block1Data Block1Data;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _CellEditableComboPrivate CellEditableComboPrivate;
enum  {
	CELL_EDITABLE_COMBO_0_PROPERTY,
	CELL_EDITABLE_COMBO_NUM_PROPERTIES
};
static GParamSpec* cell_editable_combo_properties[CELL_EDITABLE_COMBO_NUM_PROPERTIES];
typedef struct _Block2Data Block2Data;

struct _CellRendererTextishPrivate {
	GtkCellEditable* cell;
};

struct _CellEditableDummy {
	GtkEventBox parent_instance;
	CellEditableDummyPrivate * priv;
};

struct _CellEditableDummyClass {
	GtkEventBoxClass parent_class;
	void (*start_editing) (CellEditableDummy* self, GdkEvent* event);
};

struct _CellEditableDummyPrivate {
	gboolean _editing_canceled;
};

struct _CellEditableAccel {
	GtkEventBox parent_instance;
	CellEditableAccelPrivate * priv;
};

struct _CellEditableAccelClass {
	GtkEventBoxClass parent_class;
	void (*start_editing) (CellEditableAccel* self, GdkEvent* event);
};

struct _CellEditableAccelPrivate {
	gboolean _editing_canceled;
	CellRendererTextish* parent;
	gchar* path;
};

struct _Block1Data {
	int _ref_count_;
	CellEditableAccel* self;
	GtkWidget* widget;
};

struct _CellEditableCombo {
	GtkComboBoxText parent_instance;
	CellEditableComboPrivate * priv;
};

struct _CellEditableComboClass {
	GtkComboBoxTextClass parent_class;
	void (*start_editing) (CellEditableCombo* self, GdkEvent* event);
};

struct _CellEditableComboPrivate {
	CellRendererTextish* parent;
	gchar* path;
};

struct _Block2Data {
	int _ref_count_;
	CellEditableCombo* self;
	CellRendererTextish* parent;
	gchar* path;
};

static gint CellRendererTextish_private_offset;
static gpointer cell_renderer_textish_parent_class = NULL;
static gint CellEditableDummy_private_offset;
static gpointer cell_editable_dummy_parent_class = NULL;
static GtkCellEditableIface * cell_editable_dummy_gtk_cell_editable_parent_iface = NULL;
static gint CellEditableAccel_private_offset;
static gpointer cell_editable_accel_parent_class = NULL;
static GtkCellEditableIface * cell_editable_accel_gtk_cell_editable_parent_iface = NULL;
static gint CellEditableCombo_private_offset;
static gpointer cell_editable_combo_parent_class = NULL;
static GtkCellEditableIface * cell_editable_combo_gtk_cell_editable_parent_iface = NULL;

static gchar** _vala_array_dup1 (gchar** self,
                          gssize length);
static GtkCellEditable* cell_renderer_textish_real_start_editing (GtkCellRenderer* base,
                                                           GdkEvent* event,
                                                           GtkWidget* widget,
                                                           const gchar* path,
                                                           GdkRectangle* background_area,
                                                           GdkRectangle* cell_area,
                                                           GtkCellRendererState flags);
VALA_EXTERN CellEditableAccel* cell_editable_accel_new (CellRendererTextish* parent,
                                            const gchar* path,
                                            GtkWidget* widget);
VALA_EXTERN CellEditableAccel* cell_editable_accel_construct (GType object_type,
                                                  CellRendererTextish* parent,
                                                  const gchar* path,
                                                  GtkWidget* widget);
VALA_EXTERN GType cell_editable_accel_get_type (void) G_GNUC_CONST ;
VALA_EXTERN CellEditableCombo* cell_editable_combo_new (CellRendererTextish* parent,
                                            const gchar* path,
                                            GtkWidget* widget,
                                            gchar** items,
                                            gint items_length1);
VALA_EXTERN CellEditableCombo* cell_editable_combo_construct (GType object_type,
                                                  CellRendererTextish* parent,
                                                  const gchar* path,
                                                  GtkWidget* widget,
                                                  gchar** items,
                                                  gint items_length1);
VALA_EXTERN GType cell_editable_combo_get_type (void) G_GNUC_CONST ;
VALA_EXTERN CellEditableDummy* cell_editable_dummy_new (void);
VALA_EXTERN CellEditableDummy* cell_editable_dummy_construct (GType object_type);
VALA_EXTERN GType cell_editable_dummy_get_type (void) G_GNUC_CONST ;
static void g_cclosure_user_marshal_VOID__STRING_FLAGS_UINT (GClosure * closure,
                                                      GValue * return_value,
                                                      guint n_param_values,
                                                      const GValue * param_values,
                                                      gpointer invocation_hint,
                                                      gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__STRING_UINT (GClosure * closure,
                                                GValue * return_value,
                                                guint n_param_values,
                                                const GValue * param_values,
                                                gpointer invocation_hint,
                                                gpointer marshal_data);
static void cell_renderer_textish_finalize (GObject * obj);
static GType cell_renderer_textish_get_type_once (void);
VALA_EXTERN void cell_editable_dummy_start_editing (CellEditableDummy* self,
                                        GdkEvent* event);
static void cell_editable_dummy_real_start_editing (CellEditableDummy* self,
                                             GdkEvent* event);
VALA_EXTERN gboolean cell_editable_dummy_get_editing_canceled (CellEditableDummy* self);
VALA_EXTERN void cell_editable_dummy_set_editing_canceled (CellEditableDummy* self,
                                               gboolean value);
static void cell_editable_dummy_finalize (GObject * obj);
static GType cell_editable_dummy_get_type_once (void);
static void _vala_cell_editable_dummy_get_property (GObject * object,
                                             guint property_id,
                                             GValue * value,
                                             GParamSpec * pspec);
static void _vala_cell_editable_dummy_set_property (GObject * object,
                                             guint property_id,
                                             const GValue * value,
                                             GParamSpec * pspec);
VALA_EXTERN void cell_editable_accel_start_editing (CellEditableAccel* self,
                                        GdkEvent* event);
VALA_EXTERN gchar* cell_editable_accel_color_to_css (GdkRGBA* c);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static void cell_editable_accel_on_editing_done (CellEditableAccel* self);
static void _cell_editable_accel_on_editing_done_gtk_cell_editable_editing_done (GtkCellEditable* _sender,
                                                                          gpointer self);
static gboolean __lambda4_ (Block1Data* _data1_,
                     cairo_t* cr);
static gboolean ___lambda4__gtk_widget_draw (GtkWidget* _sender,
                                      cairo_t* cr,
                                      gpointer self);
static void cell_editable_accel_real_start_editing (CellEditableAccel* self,
                                             GdkEvent* event);
static gboolean cell_editable_accel_on_key (CellEditableAccel* self,
                                     GdkEventKey* event);
static gboolean _cell_editable_accel_on_key_gtk_widget_key_press_event (GtkWidget* _sender,
                                                                 GdkEventKey* event,
                                                                 gpointer self);
VALA_EXTERN gboolean cell_editable_accel_get_editing_canceled (CellEditableAccel* self);
VALA_EXTERN void cell_editable_accel_set_editing_canceled (CellEditableAccel* self,
                                               gboolean value);
static void cell_editable_accel_finalize (GObject * obj);
static GType cell_editable_accel_get_type_once (void);
static void _vala_cell_editable_accel_get_property (GObject * object,
                                             guint property_id,
                                             GValue * value,
                                             GParamSpec * pspec);
static void _vala_cell_editable_accel_set_property (GObject * object,
                                             guint property_id,
                                             const GValue * value,
                                             GParamSpec * pspec);
VALA_EXTERN void cell_editable_combo_start_editing (CellEditableCombo* self,
                                        GdkEvent* event);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
static void __lambda5_ (Block2Data* _data2_);
static void ___lambda5__gtk_combo_box_changed (GtkComboBox* _sender,
                                        gpointer self);
static void cell_editable_combo_real_start_editing (CellEditableCombo* self,
                                             GdkEvent* event);
static void cell_editable_combo_finalize (GObject * obj);
static GType cell_editable_combo_get_type_once (void);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);

static inline gpointer
cell_renderer_textish_get_instance_private (CellRendererTextish* self)
{
	return G_STRUCT_MEMBER_P (self, CellRendererTextish_private_offset);
}

static GType
cell_renderer_textish_mode_get_type_once (void)
{
	static const GEnumValue values[] = {{CELL_RENDERER_TEXTISH_MODE_Text, "CELL_RENDERER_TEXTISH_MODE_Text", "text"}, {CELL_RENDERER_TEXTISH_MODE_Key, "CELL_RENDERER_TEXTISH_MODE_Key", "key"}, {CELL_RENDERER_TEXTISH_MODE_Popup, "CELL_RENDERER_TEXTISH_MODE_Popup", "popup"}, {CELL_RENDERER_TEXTISH_MODE_Combo, "CELL_RENDERER_TEXTISH_MODE_Combo", "combo"}, {0, NULL, NULL}};
	GType cell_renderer_textish_mode_type_id;
	cell_renderer_textish_mode_type_id = g_enum_register_static ("CellRendererTextishMode", values);
	return cell_renderer_textish_mode_type_id;
}

GType
cell_renderer_textish_mode_get_type (void)
{
	static volatile gsize cell_renderer_textish_mode_type_id__once = 0;
	if (g_once_init_enter (&cell_renderer_textish_mode_type_id__once)) {
		GType cell_renderer_textish_mode_type_id;
		cell_renderer_textish_mode_type_id = cell_renderer_textish_mode_get_type_once ();
		g_once_init_leave (&cell_renderer_textish_mode_type_id__once, cell_renderer_textish_mode_type_id);
	}
	return cell_renderer_textish_mode_type_id__once;
}

CellRendererTextish*
cell_renderer_textish_construct (GType object_type)
{
	CellRendererTextish * self = NULL;
	self = (CellRendererTextish*) g_object_new (object_type, NULL);
	self->mode = CELL_RENDERER_TEXTISH_MODE_Text;
	_g_object_unref0 (self->priv->cell);
	self->priv->cell = NULL;
	self->items = (_vala_array_free (self->items, self->items_length1, (GDestroyNotify) g_free), NULL);
	self->items = NULL;
	self->items_length1 = 0;
	return self;
}

CellRendererTextish*
cell_renderer_textish_new (void)
{
	return cell_renderer_textish_construct (TYPE_CELL_RENDERER_TEXTISH);
}

static gchar**
_vala_array_dup1 (gchar** self,
                  gssize length)
{
	if (length >= 0) {
		gchar** result;
		gssize i;
		result = g_new0 (gchar*, length + 1);
		for (i = 0; i < length; i++) {
			gchar* _tmp0_;
			_tmp0_ = g_strdup (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

CellRendererTextish*
cell_renderer_textish_construct_with_items (GType object_type,
                                            gchar** items,
                                            gint items_length1)
{
	CellRendererTextish * self = NULL;
	gchar** _tmp0_;
	gint _tmp0__length1;
	self = (CellRendererTextish*) g_object_new (object_type, NULL);
	self->mode = CELL_RENDERER_TEXTISH_MODE_Text;
	_g_object_unref0 (self->priv->cell);
	self->priv->cell = NULL;
	_tmp0_ = (items != NULL) ? _vala_array_dup1 (items, items_length1) : items;
	_tmp0__length1 = items_length1;
	self->items = (_vala_array_free (self->items, self->items_length1, (GDestroyNotify) g_free), NULL);
	self->items = _tmp0_;
	self->items_length1 = _tmp0__length1;
	return self;
}

CellRendererTextish*
cell_renderer_textish_new_with_items (gchar** items,
                                      gint items_length1)
{
	return cell_renderer_textish_construct_with_items (TYPE_CELL_RENDERER_TEXTISH, items, items_length1);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static GtkCellEditable*
cell_renderer_textish_real_start_editing (GtkCellRenderer* base,
                                          GdkEvent* event,
                                          GtkWidget* widget,
                                          const gchar* path,
                                          GdkRectangle* background_area,
                                          GdkRectangle* cell_area,
                                          GtkCellRendererState flags)
{
	CellRendererTextish * self;
	gboolean _tmp0_;
	gboolean _tmp1_;
	GtkCellEditable* _tmp11_;
	GtkCellEditable* result;
	self = (CellRendererTextish*) base;
	g_return_val_if_fail (widget != NULL, NULL);
	g_return_val_if_fail (path != NULL, NULL);
	g_return_val_if_fail (background_area != NULL, NULL);
	g_return_val_if_fail (cell_area != NULL, NULL);
	_g_object_unref0 (self->priv->cell);
	self->priv->cell = NULL;
	g_object_get ((GtkCellRendererText*) self, "editable", &_tmp0_, NULL);
	_tmp1_ = _tmp0_;
	if (!_tmp1_) {
		GtkCellEditable* _tmp2_;
		_tmp2_ = self->priv->cell;
		result = _tmp2_;
		return result;
	}
	switch (self->mode) {
		case CELL_RENDERER_TEXTISH_MODE_Text:
		{
			GdkRectangle _tmp3_;
			GdkRectangle _tmp4_;
			GtkCellEditable* _tmp5_;
			GtkCellEditable* _tmp6_;
			_tmp3_ = *background_area;
			_tmp4_ = *cell_area;
			_tmp5_ = GTK_CELL_RENDERER_CLASS (cell_renderer_textish_parent_class)->start_editing ((GtkCellRenderer*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_cell_renderer_text_get_type (), GtkCellRendererText), event, widget, path, &_tmp3_, &_tmp4_, flags);
			_tmp6_ = _g_object_ref0 (_tmp5_);
			_g_object_unref0 (self->priv->cell);
			self->priv->cell = _tmp6_;
			break;
		}
		case CELL_RENDERER_TEXTISH_MODE_Key:
		{
			CellEditableAccel* _tmp7_;
			_tmp7_ = cell_editable_accel_new (self, path, widget);
			g_object_ref_sink (_tmp7_);
			_g_object_unref0 (self->priv->cell);
			self->priv->cell = (GtkCellEditable*) _tmp7_;
			break;
		}
		case CELL_RENDERER_TEXTISH_MODE_Combo:
		{
			gchar** _tmp8_;
			gint _tmp8__length1;
			CellEditableCombo* _tmp9_;
			_tmp8_ = self->items;
			_tmp8__length1 = self->items_length1;
			_tmp9_ = cell_editable_combo_new (self, path, widget, _tmp8_, _tmp8__length1);
			g_object_ref_sink (_tmp9_);
			_g_object_unref0 (self->priv->cell);
			self->priv->cell = (GtkCellEditable*) _tmp9_;
			break;
		}
		case CELL_RENDERER_TEXTISH_MODE_Popup:
		{
			CellEditableDummy* _tmp10_;
			_tmp10_ = cell_editable_dummy_new ();
			g_object_ref_sink (_tmp10_);
			_g_object_unref0 (self->priv->cell);
			self->priv->cell = (GtkCellEditable*) _tmp10_;
			break;
		}
		default:
		break;
	}
	_tmp11_ = self->priv->cell;
	result = _tmp11_;
	return result;
}

static void
g_cclosure_user_marshal_VOID__STRING_FLAGS_UINT (GClosure * closure,
                                                 GValue * return_value,
                                                 guint n_param_values,
                                                 const GValue * param_values,
                                                 gpointer invocation_hint,
                                                 gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__STRING_FLAGS_UINT) (gpointer data1, const char* arg_1, guint arg_2, guint arg_3, gpointer data2);
	register GMarshalFunc_VOID__STRING_FLAGS_UINT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 4);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_FLAGS_UINT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_flags (param_values + 2), g_value_get_uint (param_values + 3), data2);
}

static void
g_cclosure_user_marshal_VOID__STRING_UINT (GClosure * closure,
                                           GValue * return_value,
                                           guint n_param_values,
                                           const GValue * param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__STRING_UINT) (gpointer data1, const char* arg_1, guint arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_UINT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_UINT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_uint (param_values + 2), data2);
}

static void
cell_renderer_textish_class_init (CellRendererTextishClass * klass,
                                  gpointer klass_data)
{
	cell_renderer_textish_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &CellRendererTextish_private_offset);
	((GtkCellRendererClass *) klass)->start_editing = (GtkCellEditable* (*) (GtkCellRenderer*, GdkEvent*, GtkWidget*, const gchar*, GdkRectangle*, GdkRectangle*, GtkCellRendererState)) cell_renderer_textish_real_start_editing;
	G_OBJECT_CLASS (klass)->finalize = cell_renderer_textish_finalize;
	cell_renderer_textish_signals[CELL_RENDERER_TEXTISH_KEY_EDITED_SIGNAL] = g_signal_new ("key-edited", TYPE_CELL_RENDERER_TEXTISH, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_FLAGS_UINT, G_TYPE_NONE, 3, G_TYPE_STRING, gdk_modifier_type_get_type (), G_TYPE_UINT);
	cell_renderer_textish_signals[CELL_RENDERER_TEXTISH_COMBO_EDITED_SIGNAL] = g_signal_new ("combo-edited", TYPE_CELL_RENDERER_TEXTISH, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_UINT, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_UINT);
}

static void
cell_renderer_textish_instance_init (CellRendererTextish * self,
                                     gpointer klass)
{
	self->priv = cell_renderer_textish_get_instance_private (self);
}

static void
cell_renderer_textish_finalize (GObject * obj)
{
	CellRendererTextish * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CELL_RENDERER_TEXTISH, CellRendererTextish);
	self->items = (_vala_array_free (self->items, self->items_length1, (GDestroyNotify) g_free), NULL);
	_g_object_unref0 (self->priv->cell);
	G_OBJECT_CLASS (cell_renderer_textish_parent_class)->finalize (obj);
}

static GType
cell_renderer_textish_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (CellRendererTextishClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) cell_renderer_textish_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CellRendererTextish), 0, (GInstanceInitFunc) cell_renderer_textish_instance_init, NULL };
	GType cell_renderer_textish_type_id;
	cell_renderer_textish_type_id = g_type_register_static (gtk_cell_renderer_text_get_type (), "CellRendererTextish", &g_define_type_info, 0);
	CellRendererTextish_private_offset = g_type_add_instance_private (cell_renderer_textish_type_id, sizeof (CellRendererTextishPrivate));
	return cell_renderer_textish_type_id;
}

GType
cell_renderer_textish_get_type (void)
{
	static volatile gsize cell_renderer_textish_type_id__once = 0;
	if (g_once_init_enter (&cell_renderer_textish_type_id__once)) {
		GType cell_renderer_textish_type_id;
		cell_renderer_textish_type_id = cell_renderer_textish_get_type_once ();
		g_once_init_leave (&cell_renderer_textish_type_id__once, cell_renderer_textish_type_id);
	}
	return cell_renderer_textish_type_id__once;
}

static inline gpointer
cell_editable_dummy_get_instance_private (CellEditableDummy* self)
{
	return G_STRUCT_MEMBER_P (self, CellEditableDummy_private_offset);
}

static void
cell_editable_dummy_real_start_editing (CellEditableDummy* self,
                                        GdkEvent* event)
{
	gtk_cell_editable_editing_done ((GtkCellEditable*) self);
	gtk_cell_editable_remove_widget ((GtkCellEditable*) self);
}

void
cell_editable_dummy_start_editing (CellEditableDummy* self,
                                   GdkEvent* event)
{
	CellEditableDummyClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = CELL_EDITABLE_DUMMY_GET_CLASS (self);
	if (_klass_->start_editing) {
		_klass_->start_editing (self, event);
	}
}

CellEditableDummy*
cell_editable_dummy_construct (GType object_type)
{
	CellEditableDummy * self = NULL;
	self = (CellEditableDummy*) g_object_new (object_type, NULL);
	return self;
}

CellEditableDummy*
cell_editable_dummy_new (void)
{
	return cell_editable_dummy_construct (TYPE_CELL_EDITABLE_DUMMY);
}

gboolean
cell_editable_dummy_get_editing_canceled (CellEditableDummy* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_editing_canceled;
	return result;
}

void
cell_editable_dummy_set_editing_canceled (CellEditableDummy* self,
                                          gboolean value)
{
	gboolean old_value;
	g_return_if_fail (self != NULL);
	old_value = cell_editable_dummy_get_editing_canceled (self);
	if (old_value != value) {
		self->priv->_editing_canceled = value;
		g_object_notify_by_pspec ((GObject *) self, cell_editable_dummy_properties[CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY]);
	}
}

static void
cell_editable_dummy_class_init (CellEditableDummyClass * klass,
                                gpointer klass_data)
{
	cell_editable_dummy_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &CellEditableDummy_private_offset);
	((CellEditableDummyClass *) klass)->start_editing = (void (*) (CellEditableDummy*, GdkEvent*)) cell_editable_dummy_real_start_editing;
	G_OBJECT_CLASS (klass)->get_property = _vala_cell_editable_dummy_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_cell_editable_dummy_set_property;
	G_OBJECT_CLASS (klass)->finalize = cell_editable_dummy_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY, cell_editable_dummy_properties[CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY] = g_param_spec_boolean ("editing-canceled", "editing-canceled", "editing-canceled", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
}

static void
cell_editable_dummy_gtk_cell_editable_interface_init (GtkCellEditableIface * iface,
                                                      gpointer iface_data)
{
	cell_editable_dummy_gtk_cell_editable_parent_iface = g_type_interface_peek_parent (iface);
	iface->start_editing = (void (*) (GtkCellEditable*, GdkEvent*)) cell_editable_dummy_start_editing;
}

static void
cell_editable_dummy_instance_init (CellEditableDummy * self,
                                   gpointer klass)
{
	self->priv = cell_editable_dummy_get_instance_private (self);
}

static void
cell_editable_dummy_finalize (GObject * obj)
{
	CellEditableDummy * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CELL_EDITABLE_DUMMY, CellEditableDummy);
	G_OBJECT_CLASS (cell_editable_dummy_parent_class)->finalize (obj);
}

static GType
cell_editable_dummy_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (CellEditableDummyClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) cell_editable_dummy_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CellEditableDummy), 0, (GInstanceInitFunc) cell_editable_dummy_instance_init, NULL };
	static const GInterfaceInfo gtk_cell_editable_info = { (GInterfaceInitFunc) cell_editable_dummy_gtk_cell_editable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType cell_editable_dummy_type_id;
	cell_editable_dummy_type_id = g_type_register_static (gtk_event_box_get_type (), "CellEditableDummy", &g_define_type_info, 0);
	g_type_add_interface_static (cell_editable_dummy_type_id, gtk_cell_editable_get_type (), &gtk_cell_editable_info);
	CellEditableDummy_private_offset = g_type_add_instance_private (cell_editable_dummy_type_id, sizeof (CellEditableDummyPrivate));
	return cell_editable_dummy_type_id;
}

GType
cell_editable_dummy_get_type (void)
{
	static volatile gsize cell_editable_dummy_type_id__once = 0;
	if (g_once_init_enter (&cell_editable_dummy_type_id__once)) {
		GType cell_editable_dummy_type_id;
		cell_editable_dummy_type_id = cell_editable_dummy_get_type_once ();
		g_once_init_leave (&cell_editable_dummy_type_id__once, cell_editable_dummy_type_id);
	}
	return cell_editable_dummy_type_id__once;
}

static void
_vala_cell_editable_dummy_get_property (GObject * object,
                                        guint property_id,
                                        GValue * value,
                                        GParamSpec * pspec)
{
	CellEditableDummy * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CELL_EDITABLE_DUMMY, CellEditableDummy);
	switch (property_id) {
		case CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY:
		g_value_set_boolean (value, cell_editable_dummy_get_editing_canceled (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_cell_editable_dummy_set_property (GObject * object,
                                        guint property_id,
                                        const GValue * value,
                                        GParamSpec * pspec)
{
	CellEditableDummy * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CELL_EDITABLE_DUMMY, CellEditableDummy);
	switch (property_id) {
		case CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY:
		cell_editable_dummy_set_editing_canceled (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
cell_editable_accel_get_instance_private (CellEditableAccel* self)
{
	return G_STRUCT_MEMBER_P (self, CellEditableAccel_private_offset);
}

static gchar*
double_to_string (gdouble self)
{
	gchar* _tmp0_;
	gchar* _tmp1_;
	gint _tmp1__length1;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* result;
	_tmp0_ = g_new0 (gchar, G_ASCII_DTOSTR_BUF_SIZE);
	_tmp1_ = _tmp0_;
	_tmp1__length1 = G_ASCII_DTOSTR_BUF_SIZE;
	_tmp2_ = g_ascii_dtostr (_tmp1_, (gint) G_ASCII_DTOSTR_BUF_SIZE, self);
	_tmp3_ = g_strdup (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp1_ = (g_free (_tmp1_), NULL);
	result = _tmp4_;
	return result;
}

gchar*
cell_editable_accel_color_to_css (GdkRGBA* c)
{
	GdkRGBA _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	GdkRGBA _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_;
	gchar* _tmp13_;
	GdkRGBA _tmp14_;
	gchar* _tmp15_;
	gchar* _tmp16_;
	gchar* _tmp17_;
	gchar* _tmp18_;
	gchar* _tmp19_;
	gchar* _tmp20_;
	GdkRGBA _tmp21_;
	gchar* _tmp22_;
	gchar* _tmp23_;
	gchar* _tmp24_;
	gchar* _tmp25_;
	gchar* _tmp26_;
	gchar* _tmp27_;
	gchar* result;
	g_return_val_if_fail (c != NULL, NULL);
	_tmp0_ = *c;
	_tmp1_ = g_strdup_printf ("%i", (gint) (_tmp0_.red * 255));
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strconcat ("rgba(", _tmp2_, NULL);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_strconcat (_tmp4_, ",", NULL);
	_tmp6_ = _tmp5_;
	_tmp7_ = *c;
	_tmp8_ = g_strdup_printf ("%i", (gint) (_tmp7_.green * 255));
	_tmp9_ = _tmp8_;
	_tmp10_ = g_strconcat (_tmp6_, _tmp9_, NULL);
	_tmp11_ = _tmp10_;
	_tmp12_ = g_strconcat (_tmp11_, ",", NULL);
	_tmp13_ = _tmp12_;
	_tmp14_ = *c;
	_tmp15_ = g_strdup_printf ("%i", (gint) (_tmp14_.blue * 255));
	_tmp16_ = _tmp15_;
	_tmp17_ = g_strconcat (_tmp13_, _tmp16_, NULL);
	_tmp18_ = _tmp17_;
	_tmp19_ = g_strconcat (_tmp18_, ",", NULL);
	_tmp20_ = _tmp19_;
	_tmp21_ = *c;
	_tmp22_ = double_to_string (_tmp21_.alpha);
	_tmp23_ = _tmp22_;
	_tmp24_ = g_strconcat (_tmp20_, _tmp23_, NULL);
	_tmp25_ = _tmp24_;
	_tmp26_ = g_strconcat (_tmp25_, ")", NULL);
	_tmp27_ = _tmp26_;
	_g_free0 (_tmp25_);
	_g_free0 (_tmp23_);
	_g_free0 (_tmp20_);
	_g_free0 (_tmp18_);
	_g_free0 (_tmp16_);
	_g_free0 (_tmp13_);
	_g_free0 (_tmp11_);
	_g_free0 (_tmp9_);
	_g_free0 (_tmp6_);
	_g_free0 (_tmp4_);
	_g_free0 (_tmp2_);
	result = _tmp27_;
	return result;
}

static Block1Data*
block1_data_ref (Block1Data* _data1_)
{
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}

static void
block1_data_unref (void * _userdata_)
{
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		CellEditableAccel* self;
		self = _data1_->self;
		_g_object_unref0 (_data1_->widget);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}

static void
_cell_editable_accel_on_editing_done_gtk_cell_editable_editing_done (GtkCellEditable* _sender,
                                                                     gpointer self)
{
	cell_editable_accel_on_editing_done ((CellEditableAccel*) self);
}

static gboolean
__lambda4_ (Block1Data* _data1_,
            cairo_t* cr)
{
	CellEditableAccel* self;
	GtkStyleContext* context = NULL;
	GtkStyleContext* _tmp0_;
	GtkStyleContext* _tmp1_;
	GdkRectangle alloc = {0};
	GtkAllocation _tmp2_ = {0};
	GdkRectangle _tmp3_;
	GdkRectangle _tmp4_;
	GdkRectangle _tmp5_;
	GdkRectangle _tmp6_;
	gboolean result;
	self = _data1_->self;
	g_return_val_if_fail (cr != NULL, FALSE);
	_tmp0_ = gtk_widget_get_style_context (_data1_->widget);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	context = _tmp1_;
	gtk_widget_get_allocation ((GtkWidget*) self, &_tmp2_);
	alloc = _tmp2_;
	gtk_style_context_save (context);
	gtk_style_context_set_state (context, GTK_STATE_FLAG_SELECTED);
	_tmp3_ = alloc;
	_tmp4_ = alloc;
	_tmp5_ = alloc;
	_tmp6_ = alloc;
	gtk_render_background (context, cr, (gdouble) _tmp3_.x, (gdouble) _tmp4_.y, (gdouble) _tmp5_.width, (gdouble) _tmp6_.height);
	gtk_style_context_restore (context);
	result = FALSE;
	_g_object_unref0 (context);
	return result;
}

static gboolean
___lambda4__gtk_widget_draw (GtkWidget* _sender,
                             cairo_t* cr,
                             gpointer self)
{
	gboolean result;
	result = __lambda4_ (self, cr);
	return result;
}

CellEditableAccel*
cell_editable_accel_construct (GType object_type,
                               CellRendererTextish* parent,
                               const gchar* path,
                               GtkWidget* widget)
{
	CellEditableAccel * self = NULL;
	Block1Data* _data1_;
	GtkWidget* _tmp0_;
	CellRendererTextish* _tmp1_;
	gchar* _tmp2_;
	GtkLabel* label = NULL;
	GtkLabel* _tmp3_;
	GtkStyleContext* _tmp4_;
	GtkCssProvider* css = NULL;
	GtkCssProvider* _tmp5_;
	GtkStyleContext* _tmp16_;
	GError* _inner_error0_ = NULL;
	g_return_val_if_fail (parent != NULL, NULL);
	g_return_val_if_fail (path != NULL, NULL);
	g_return_val_if_fail (widget != NULL, NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_tmp0_ = _g_object_ref0 (widget);
	_g_object_unref0 (_data1_->widget);
	_data1_->widget = _tmp0_;
	self = (CellEditableAccel*) g_object_new (object_type, NULL);
	_data1_->self = g_object_ref (self);
	_tmp1_ = _g_object_ref0 (parent);
	_g_object_unref0 (self->priv->parent);
	self->priv->parent = _tmp1_;
	_tmp2_ = g_strdup (path);
	_g_free0 (self->priv->path);
	self->priv->path = _tmp2_;
	g_signal_connect_object ((GtkCellEditable*) self, "editing-done", (GCallback) _cell_editable_accel_on_editing_done_gtk_cell_editable_editing_done, self, 0);
	_tmp3_ = (GtkLabel*) gtk_label_new (_ ("Key combination..."));
	g_object_ref_sink (_tmp3_);
	label = _tmp3_;
	gtk_misc_set_alignment ((GtkMisc*) label, 0.0f, 0.5f);
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) label);
	_tmp4_ = gtk_widget_get_style_context ((GtkWidget*) label);
	gtk_style_context_add_class (_tmp4_, "selected-label");
	_tmp5_ = gtk_css_provider_new ();
	css = _tmp5_;
	{
		GtkStyleContext* _tmp6_;
		GdkRGBA _tmp7_ = {0};
		gchar* _tmp8_;
		gchar* _tmp9_;
		gchar* _tmp10_;
		gchar* _tmp11_;
		gchar* _tmp12_;
		gchar* _tmp13_;
		_tmp6_ = gtk_widget_get_style_context (_data1_->widget);
		gtk_style_context_get_color (_tmp6_, GTK_STATE_FLAG_SELECTED, &_tmp7_);
		_tmp8_ = cell_editable_accel_color_to_css (&_tmp7_);
		_tmp9_ = _tmp8_;
		_tmp10_ = g_strconcat (".selected-label { color: ", _tmp9_, NULL);
		_tmp11_ = _tmp10_;
		_tmp12_ = g_strconcat (_tmp11_, "; }", NULL);
		_tmp13_ = _tmp12_;
		gtk_css_provider_load_from_data (css, _tmp13_, (gssize) -1, &_inner_error0_);
		_g_free0 (_tmp13_);
		_g_free0 (_tmp11_);
		_g_free0 (_tmp9_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp14_;
		const gchar* _tmp15_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp14_ = e;
		_tmp15_ = _tmp14_->message;
		g_warning ("cellrenderertextish.vala:76: Failed to load CSS: %s", _tmp15_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_object_unref0 (css);
		_g_object_unref0 (label);
		block1_data_unref (_data1_);
		_data1_ = NULL;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return NULL;
	}
	_tmp16_ = gtk_widget_get_style_context ((GtkWidget*) label);
	gtk_style_context_add_provider (_tmp16_, (GtkStyleProvider*) css, (guint) GTK_STYLE_PROVIDER_PRIORITY_USER);
	gtk_widget_show_all ((GtkWidget*) self);
	g_signal_connect_data ((GtkWidget*) self, "draw", (GCallback) ___lambda4__gtk_widget_draw, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	_g_object_unref0 (css);
	_g_object_unref0 (label);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return self;
}

CellEditableAccel*
cell_editable_accel_new (CellRendererTextish* parent,
                         const gchar* path,
                         GtkWidget* widget)
{
	return cell_editable_accel_construct (TYPE_CELL_EDITABLE_ACCEL, parent, path, widget);
}

static gboolean
_cell_editable_accel_on_key_gtk_widget_key_press_event (GtkWidget* _sender,
                                                        GdkEventKey* event,
                                                        gpointer self)
{
	gboolean result;
	result = cell_editable_accel_on_key ((CellEditableAccel*) self, event);
	return result;
}

static void
cell_editable_accel_real_start_editing (CellEditableAccel* self,
                                        GdkEvent* event)
{
	GdkSeat* seat = NULL;
	GdkWindow* _tmp0_;
	GdkDisplay* _tmp1_;
	GdkSeat* _tmp2_;
	GdkSeat* _tmp3_;
	GdkWindow* _tmp4_;
	gtk_grab_add ((GtkWidget*) self);
	_tmp0_ = gtk_widget_get_window ((GtkWidget*) self);
	_tmp1_ = gdk_window_get_display (_tmp0_);
	_tmp2_ = gdk_display_get_default_seat (_tmp1_);
	_tmp3_ = _g_object_ref0 (_tmp2_);
	seat = _tmp3_;
	_tmp4_ = gtk_widget_get_window ((GtkWidget*) self);
	gdk_seat_grab (seat, _tmp4_, GDK_SEAT_CAPABILITY_KEYBOARD, FALSE, NULL, event, NULL, NULL);
	g_signal_connect_object ((GtkWidget*) self, "key-press-event", (GCallback) _cell_editable_accel_on_key_gtk_widget_key_press_event, self, 0);
	_g_object_unref0 (seat);
}

void
cell_editable_accel_start_editing (CellEditableAccel* self,
                                   GdkEvent* event)
{
	CellEditableAccelClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = CELL_EDITABLE_ACCEL_GET_CLASS (self);
	if (_klass_->start_editing) {
		_klass_->start_editing (self, event);
	}
}

static gboolean
cell_editable_accel_on_key (CellEditableAccel* self,
                            GdkEventKey* event)
{
	GdkModifierType mods = 0U;
	CellRendererTextish* _tmp0_;
	const gchar* _tmp1_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	if (event->is_modifier != ((guint) 0)) {
		result = TRUE;
		return result;
	}
	switch (event->keyval) {
		case GDK_KEY_Super_L:
		case GDK_KEY_Super_R:
		case GDK_KEY_Hyper_L:
		case GDK_KEY_Hyper_R:
		{
			result = TRUE;
			return result;
		}
		default:
		break;
	}
	mods = event->state & gtk_accelerator_get_default_mod_mask ();
	gtk_cell_editable_editing_done ((GtkCellEditable*) self);
	gtk_cell_editable_remove_widget ((GtkCellEditable*) self);
	_tmp0_ = self->priv->parent;
	_tmp1_ = self->priv->path;
	g_signal_emit (_tmp0_, cell_renderer_textish_signals[CELL_RENDERER_TEXTISH_KEY_EDITED_SIGNAL], 0, _tmp1_, mods, (guint) event->hardware_keycode);
	result = TRUE;
	return result;
}

static void
cell_editable_accel_on_editing_done (CellEditableAccel* self)
{
	GdkSeat* seat = NULL;
	GdkWindow* _tmp0_;
	GdkDisplay* _tmp1_;
	GdkSeat* _tmp2_;
	GdkSeat* _tmp3_;
	g_return_if_fail (self != NULL);
	gtk_grab_remove ((GtkWidget*) self);
	_tmp0_ = gtk_widget_get_window ((GtkWidget*) self);
	_tmp1_ = gdk_window_get_display (_tmp0_);
	_tmp2_ = gdk_display_get_default_seat (_tmp1_);
	_tmp3_ = _g_object_ref0 (_tmp2_);
	seat = _tmp3_;
	gdk_seat_ungrab (seat);
	_g_object_unref0 (seat);
}

gboolean
cell_editable_accel_get_editing_canceled (CellEditableAccel* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_editing_canceled;
	return result;
}

void
cell_editable_accel_set_editing_canceled (CellEditableAccel* self,
                                          gboolean value)
{
	gboolean old_value;
	g_return_if_fail (self != NULL);
	old_value = cell_editable_accel_get_editing_canceled (self);
	if (old_value != value) {
		self->priv->_editing_canceled = value;
		g_object_notify_by_pspec ((GObject *) self, cell_editable_accel_properties[CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY]);
	}
}

static void
cell_editable_accel_class_init (CellEditableAccelClass * klass,
                                gpointer klass_data)
{
	cell_editable_accel_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &CellEditableAccel_private_offset);
	((CellEditableAccelClass *) klass)->start_editing = (void (*) (CellEditableAccel*, GdkEvent*)) cell_editable_accel_real_start_editing;
	G_OBJECT_CLASS (klass)->get_property = _vala_cell_editable_accel_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_cell_editable_accel_set_property;
	G_OBJECT_CLASS (klass)->finalize = cell_editable_accel_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY, cell_editable_accel_properties[CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY] = g_param_spec_boolean ("editing-canceled", "editing-canceled", "editing-canceled", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
}

static void
cell_editable_accel_gtk_cell_editable_interface_init (GtkCellEditableIface * iface,
                                                      gpointer iface_data)
{
	cell_editable_accel_gtk_cell_editable_parent_iface = g_type_interface_peek_parent (iface);
	iface->start_editing = (void (*) (GtkCellEditable*, GdkEvent*)) cell_editable_accel_start_editing;
}

static void
cell_editable_accel_instance_init (CellEditableAccel * self,
                                   gpointer klass)
{
	self->priv = cell_editable_accel_get_instance_private (self);
}

static void
cell_editable_accel_finalize (GObject * obj)
{
	CellEditableAccel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CELL_EDITABLE_ACCEL, CellEditableAccel);
	_g_object_unref0 (self->priv->parent);
	_g_free0 (self->priv->path);
	G_OBJECT_CLASS (cell_editable_accel_parent_class)->finalize (obj);
}

static GType
cell_editable_accel_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (CellEditableAccelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) cell_editable_accel_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CellEditableAccel), 0, (GInstanceInitFunc) cell_editable_accel_instance_init, NULL };
	static const GInterfaceInfo gtk_cell_editable_info = { (GInterfaceInitFunc) cell_editable_accel_gtk_cell_editable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType cell_editable_accel_type_id;
	cell_editable_accel_type_id = g_type_register_static (gtk_event_box_get_type (), "CellEditableAccel", &g_define_type_info, 0);
	g_type_add_interface_static (cell_editable_accel_type_id, gtk_cell_editable_get_type (), &gtk_cell_editable_info);
	CellEditableAccel_private_offset = g_type_add_instance_private (cell_editable_accel_type_id, sizeof (CellEditableAccelPrivate));
	return cell_editable_accel_type_id;
}

GType
cell_editable_accel_get_type (void)
{
	static volatile gsize cell_editable_accel_type_id__once = 0;
	if (g_once_init_enter (&cell_editable_accel_type_id__once)) {
		GType cell_editable_accel_type_id;
		cell_editable_accel_type_id = cell_editable_accel_get_type_once ();
		g_once_init_leave (&cell_editable_accel_type_id__once, cell_editable_accel_type_id);
	}
	return cell_editable_accel_type_id__once;
}

static void
_vala_cell_editable_accel_get_property (GObject * object,
                                        guint property_id,
                                        GValue * value,
                                        GParamSpec * pspec)
{
	CellEditableAccel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CELL_EDITABLE_ACCEL, CellEditableAccel);
	switch (property_id) {
		case CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY:
		g_value_set_boolean (value, cell_editable_accel_get_editing_canceled (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_cell_editable_accel_set_property (GObject * object,
                                        guint property_id,
                                        const GValue * value,
                                        GParamSpec * pspec)
{
	CellEditableAccel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CELL_EDITABLE_ACCEL, CellEditableAccel);
	switch (property_id) {
		case CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY:
		cell_editable_accel_set_editing_canceled (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
cell_editable_combo_get_instance_private (CellEditableCombo* self)
{
	return G_STRUCT_MEMBER_P (self, CellEditableCombo_private_offset);
}

static Block2Data*
block2_data_ref (Block2Data* _data2_)
{
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}

static void
block2_data_unref (void * _userdata_)
{
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		CellEditableCombo* self;
		self = _data2_->self;
		_g_object_unref0 (_data2_->parent);
		_g_free0 (_data2_->path);
		_g_object_unref0 (self);
		g_slice_free (Block2Data, _data2_);
	}
}

static void
__lambda5_ (Block2Data* _data2_)
{
	CellEditableCombo* self;
	gint _tmp0_;
	gint _tmp1_;
	self = _data2_->self;
	_tmp0_ = gtk_combo_box_get_active ((GtkComboBox*) self);
	_tmp1_ = _tmp0_;
	g_signal_emit (_data2_->parent, cell_renderer_textish_signals[CELL_RENDERER_TEXTISH_COMBO_EDITED_SIGNAL], 0, _data2_->path, (guint) _tmp1_);
}

static void
___lambda5__gtk_combo_box_changed (GtkComboBox* _sender,
                                   gpointer self)
{
	__lambda5_ (self);
}

CellEditableCombo*
cell_editable_combo_construct (GType object_type,
                               CellRendererTextish* parent,
                               const gchar* path,
                               GtkWidget* widget,
                               gchar** items,
                               gint items_length1)
{
	CellEditableCombo * self = NULL;
	Block2Data* _data2_;
	CellRendererTextish* _tmp0_;
	gchar* _tmp1_;
	CellRendererTextish* _tmp2_;
	gchar* _tmp3_;
	g_return_val_if_fail (parent != NULL, NULL);
	g_return_val_if_fail (path != NULL, NULL);
	g_return_val_if_fail (widget != NULL, NULL);
	_data2_ = g_slice_new0 (Block2Data);
	_data2_->_ref_count_ = 1;
	_tmp0_ = _g_object_ref0 (parent);
	_g_object_unref0 (_data2_->parent);
	_data2_->parent = _tmp0_;
	_tmp1_ = g_strdup (path);
	_g_free0 (_data2_->path);
	_data2_->path = _tmp1_;
	self = (CellEditableCombo*) g_object_new (object_type, NULL);
	_data2_->self = g_object_ref (self);
	_tmp2_ = _g_object_ref0 (_data2_->parent);
	_g_object_unref0 (self->priv->parent);
	self->priv->parent = _tmp2_;
	_tmp3_ = g_strdup (_data2_->path);
	_g_free0 (self->priv->path);
	self->priv->path = _tmp3_;
	{
		gchar** item_collection = NULL;
		gint item_collection_length1 = 0;
		gint _item_collection_size_ = 0;
		gint item_it = 0;
		item_collection = items;
		item_collection_length1 = items_length1;
		for (item_it = 0; item_it < item_collection_length1; item_it = item_it + 1) {
			gchar* _tmp4_;
			gchar* item = NULL;
			_tmp4_ = g_strdup (item_collection[item_it]);
			item = _tmp4_;
			{
				const gchar* _tmp5_;
				_tmp5_ = item;
				gtk_combo_box_text_append_text ((GtkComboBoxText*) self, _ (_tmp5_));
				_g_free0 (item);
			}
		}
	}
	g_signal_connect_data ((GtkComboBox*) self, "changed", (GCallback) ___lambda5__gtk_combo_box_changed, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
	block2_data_unref (_data2_);
	_data2_ = NULL;
	return self;
}

CellEditableCombo*
cell_editable_combo_new (CellRendererTextish* parent,
                         const gchar* path,
                         GtkWidget* widget,
                         gchar** items,
                         gint items_length1)
{
	return cell_editable_combo_construct (TYPE_CELL_EDITABLE_COMBO, parent, path, widget, items, items_length1);
}

static void
cell_editable_combo_real_start_editing (CellEditableCombo* self,
                                        GdkEvent* event)
{
	cell_editable_combo_gtk_cell_editable_parent_iface->start_editing ((GtkCellEditable*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_combo_box_text_get_type (), GtkComboBoxText), event);
	gtk_widget_show_all ((GtkWidget*) self);
}

void
cell_editable_combo_start_editing (CellEditableCombo* self,
                                   GdkEvent* event)
{
	CellEditableComboClass* _klass_;
	g_return_if_fail (self != NULL);
	_klass_ = CELL_EDITABLE_COMBO_GET_CLASS (self);
	if (_klass_->start_editing) {
		_klass_->start_editing (self, event);
	}
}

static void
cell_editable_combo_class_init (CellEditableComboClass * klass,
                                gpointer klass_data)
{
	cell_editable_combo_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &CellEditableCombo_private_offset);
	((CellEditableComboClass *) klass)->start_editing = (void (*) (CellEditableCombo*, GdkEvent*)) cell_editable_combo_real_start_editing;
	G_OBJECT_CLASS (klass)->finalize = cell_editable_combo_finalize;
}

static void
cell_editable_combo_gtk_cell_editable_interface_init (GtkCellEditableIface * iface,
                                                      gpointer iface_data)
{
	cell_editable_combo_gtk_cell_editable_parent_iface = g_type_interface_peek_parent (iface);
	iface->start_editing = (void (*) (GtkCellEditable*, GdkEvent*)) cell_editable_combo_start_editing;
}

static void
cell_editable_combo_instance_init (CellEditableCombo * self,
                                   gpointer klass)
{
	self->priv = cell_editable_combo_get_instance_private (self);
}

static void
cell_editable_combo_finalize (GObject * obj)
{
	CellEditableCombo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CELL_EDITABLE_COMBO, CellEditableCombo);
	_g_object_unref0 (self->priv->parent);
	_g_free0 (self->priv->path);
	G_OBJECT_CLASS (cell_editable_combo_parent_class)->finalize (obj);
}

static GType
cell_editable_combo_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (CellEditableComboClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) cell_editable_combo_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CellEditableCombo), 0, (GInstanceInitFunc) cell_editable_combo_instance_init, NULL };
	static const GInterfaceInfo gtk_cell_editable_info = { (GInterfaceInitFunc) cell_editable_combo_gtk_cell_editable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType cell_editable_combo_type_id;
	cell_editable_combo_type_id = g_type_register_static (gtk_combo_box_text_get_type (), "CellEditableCombo", &g_define_type_info, 0);
	g_type_add_interface_static (cell_editable_combo_type_id, gtk_cell_editable_get_type (), &gtk_cell_editable_info);
	CellEditableCombo_private_offset = g_type_add_instance_private (cell_editable_combo_type_id, sizeof (CellEditableComboPrivate));
	return cell_editable_combo_type_id;
}

GType
cell_editable_combo_get_type (void)
{
	static volatile gsize cell_editable_combo_type_id__once = 0;
	if (g_once_init_enter (&cell_editable_combo_type_id__once)) {
		GType cell_editable_combo_type_id;
		cell_editable_combo_type_id = cell_editable_combo_get_type_once ();
		g_once_init_leave (&cell_editable_combo_type_id__once, cell_editable_combo_type_id);
	}
	return cell_editable_combo_type_id__once;
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

